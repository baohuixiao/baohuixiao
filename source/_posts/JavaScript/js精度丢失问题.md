---
title: js精度丢失问题
---

比如0.1+0.2并不等于0.3

JavaScript 里的数字是采用IEEE 754标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持52位，就会出现运算精度问题。

这会导致以下几个问题

* 和服务端的数据对不上
* 没办法和我们理想中的值进行比较

解决这个问题的方案也比较简单：

出现这个问题的情况主要是计算的数字中有浮点数，那么这个好办，那就先将数字转化为十进制，这样就不存在精度丢失了，然后再转成浮点数

不bb，直接贴段代码，要举一反三哦

```javascript
function addFloatNum(num1, num2) {
  // 第一步，找出数字中小数位的位数
  const num1Len = num1.toString().split('.')[1]?.length || 0;
  const num2Len = num2.toString().split('.')[1]?.length || 0;
  // 第二步，利用最大的小数位数，计算出要把所有数字专为整数的乘数
  const maxLen = Math.pow(10, Math.max(num1Len, num2Len));
  // 第三步，现将数字都乘以第二步所得乘数，转成整数，然后进行计算
  // 第四步，获得计算后的整数值，再将整数值除以第三步的结果，转化回浮点数
  return (num1 * maxLen + num2 * maxLen) / maxLen;
}
```

上面所贴代码只能进行两个数字的处理，后续可以利用柯里化解决多个数字的处理，目前对柯里化不太熟悉，后续熟悉了再优化
